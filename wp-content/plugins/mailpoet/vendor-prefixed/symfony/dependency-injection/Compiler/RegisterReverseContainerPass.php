<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection\Compiler; if (!defined('ABSPATH')) exit; use MailPoetVendor\Symfony\Component\DependencyInjection\Argument\ServiceClosureArgument; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\Definition; use MailPoetVendor\Symfony\Component\DependencyInjection\Reference; class RegisterReverseContainerPass implements CompilerPassInterface { private $beforeRemoving; private $serviceId; private $tagName; public function __construct(bool $beforeRemoving, string $serviceId = 'reverse_container', string $tagName = 'container.reversible') { $this->beforeRemoving = $beforeRemoving; $this->serviceId = $serviceId; $this->tagName = $tagName; } public function process(ContainerBuilder $container) { if (!$container->hasDefinition($this->serviceId)) { return; } $refType = $this->beforeRemoving ? ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE : ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE; $services = []; foreach ($container->findTaggedServiceIds($this->tagName) as $id => $tags) { $services[$id] = new Reference($id, $refType); } if ($this->beforeRemoving) { $services[$this->serviceId] = new Reference($this->serviceId, $refType); } $locator = $container->getDefinition($this->serviceId)->getArgument(1); if ($locator instanceof Reference) { $locator = $container->getDefinition((string) $locator); } if ($locator instanceof Definition) { foreach ($services as $id => $ref) { $services[$id] = new ServiceClosureArgument($ref); } $locator->replaceArgument(0, $services); } else { $locator->setValues($services); } } } 