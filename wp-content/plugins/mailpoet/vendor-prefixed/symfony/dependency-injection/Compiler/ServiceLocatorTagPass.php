<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection\Compiler; if (!defined('ABSPATH')) exit; use MailPoetVendor\Symfony\Component\DependencyInjection\Alias; use MailPoetVendor\Symfony\Component\DependencyInjection\Argument\ServiceClosureArgument; use MailPoetVendor\Symfony\Component\DependencyInjection\Argument\ServiceLocatorArgument; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder; use MailPoetVendor\Symfony\Component\DependencyInjection\Definition; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException; use MailPoetVendor\Symfony\Component\DependencyInjection\Reference; use MailPoetVendor\Symfony\Component\DependencyInjection\ServiceLocator; final class ServiceLocatorTagPass extends AbstractRecursivePass { use PriorityTaggedServiceTrait; protected function processValue($value, $isRoot = \false) { if ($value instanceof ServiceLocatorArgument) { if ($value->getTaggedIteratorArgument()) { $value->setValues($this->findAndSortTaggedServices($value->getTaggedIteratorArgument(), $this->container)); } return self::register($this->container, $value->getValues()); } if (!$value instanceof Definition || !$value->hasTag('container.service_locator')) { return parent::processValue($value, $isRoot); } if (!$value->getClass()) { $value->setClass(ServiceLocator::class); } $arguments = $value->getArguments(); if (!isset($arguments[0]) || !\is_array($arguments[0])) { throw new InvalidArgumentException(\sprintf('Invalid definition for service "%s": an array of references is expected as first argument when the "container.service_locator" tag is set.', $this->currentId)); } $i = 0; foreach ($arguments[0] as $k => $v) { if ($v instanceof ServiceClosureArgument) { continue; } if (!$v instanceof Reference) { throw new InvalidArgumentException(\sprintf('Invalid definition for service "%s": an array of references is expected as first argument when the "container.service_locator" tag is set, "%s" found for key "%s".', $this->currentId, \is_object($v) ? \get_class($v) : \gettype($v), $k)); } if ($i === $k) { unset($arguments[0][$k]); $k = (string) $v; ++$i; } elseif (\is_int($k)) { $i = null; } $arguments[0][$k] = new ServiceClosureArgument($v); } \ksort($arguments[0]); $value->setArguments($arguments); $id = '.service_locator.' . ContainerBuilder::hash($value); if ($isRoot) { if ($id !== $this->currentId) { $this->container->setAlias($id, new Alias($this->currentId, \false)); } return $value; } $this->container->setDefinition($id, $value->setPublic(\false)); return new Reference($id); } public static function register(ContainerBuilder $container, array $refMap, string $callerId = null) : Reference { foreach ($refMap as $id => $ref) { if (!$ref instanceof Reference) { throw new InvalidArgumentException(\sprintf('Invalid service locator definition: only services can be referenced, "%s" found for key "%s". Inject parameter values using constructors instead.', \is_object($ref) ? \get_class($ref) : \gettype($ref), $id)); } $refMap[$id] = new ServiceClosureArgument($ref); } \ksort($refMap); $locator = (new Definition(ServiceLocator::class))->addArgument($refMap)->setPublic(\false)->addTag('container.service_locator'); if (null !== $callerId && $container->hasDefinition($callerId)) { $locator->setBindings($container->getDefinition($callerId)->getBindings()); } if (!$container->hasDefinition($id = '.service_locator.' . ContainerBuilder::hash($locator))) { $container->setDefinition($id, $locator); } if (null !== $callerId) { $locatorId = $id; $container->register($id .= '.' . $callerId, ServiceLocator::class)->setPublic(\false)->setFactory([new Reference($locatorId), 'withContext'])->addTag('container.service_locator_context', ['id' => $callerId])->addArgument($callerId)->addArgument(new Reference('service_container')); } return new Reference($id); } } 