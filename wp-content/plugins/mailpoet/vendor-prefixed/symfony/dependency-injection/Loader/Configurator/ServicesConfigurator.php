<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection\Loader\Configurator; if (!defined('ABSPATH')) exit; use MailPoetVendor\Symfony\Component\DependencyInjection\Alias; use MailPoetVendor\Symfony\Component\DependencyInjection\ChildDefinition; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder; use MailPoetVendor\Symfony\Component\DependencyInjection\Definition; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException; use MailPoetVendor\Symfony\Component\DependencyInjection\Loader\PhpFileLoader; class ServicesConfigurator extends AbstractConfigurator { public const FACTORY = 'services'; private $defaults; private $container; private $loader; private $instanceof; private $path; private $anonymousHash; private $anonymousCount; public function __construct(ContainerBuilder $container, PhpFileLoader $loader, array &$instanceof, string $path = null, int &$anonymousCount = 0) { $this->defaults = new Definition(); $this->container = $container; $this->loader = $loader; $this->instanceof =& $instanceof; $this->path = $path; $this->anonymousHash = ContainerBuilder::hash($path ?: \mt_rand()); $this->anonymousCount =& $anonymousCount; $instanceof = []; } public final function defaults() : DefaultsConfigurator { return new DefaultsConfigurator($this, $this->defaults = new Definition(), $this->path); } public final function instanceof(string $fqcn) : InstanceofConfigurator { $this->instanceof[$fqcn] = $definition = new ChildDefinition(''); return new InstanceofConfigurator($this, $definition, $fqcn, $this->path); } public final function set(?string $id, string $class = null) : ServiceConfigurator { $defaults = $this->defaults; $allowParent = !$defaults->getChanges() && empty($this->instanceof); $definition = new Definition(); if (null === $id) { if (!$class) { throw new \LogicException('Anonymous services must have a class name.'); } $id = \sprintf('.%d_%s', ++$this->anonymousCount, \preg_replace('/^.*\\\\/', '', $class) . '~' . $this->anonymousHash); $definition->setPublic(\false); } elseif (!$defaults->isPublic() || !$defaults->isPrivate()) { $definition->setPublic($defaults->isPublic() && !$defaults->isPrivate()); } $definition->setAutowired($defaults->isAutowired()); $definition->setAutoconfigured($defaults->isAutoconfigured()); $definition->setBindings(\unserialize(\serialize($defaults->getBindings()))); $definition->setChanges([]); $configurator = new ServiceConfigurator($this->container, $this->instanceof, $allowParent, $this, $definition, $id, $defaults->getTags(), $this->path); return null !== $class ? $configurator->class($class) : $configurator; } public final function alias(string $id, string $referencedId) : AliasConfigurator { $ref = static::processValue($referencedId, \true); $alias = new Alias((string) $ref); if (!$this->defaults->isPublic() || !$this->defaults->isPrivate()) { $alias->setPublic($this->defaults->isPublic()); } $this->container->setAlias($id, $alias); return new AliasConfigurator($this, $alias); } public final function load(string $namespace, string $resource) : PrototypeConfigurator { $allowParent = !$this->defaults->getChanges() && empty($this->instanceof); return new PrototypeConfigurator($this, $this->loader, $this->defaults, $namespace, $resource, $allowParent); } public final function get(string $id) : ServiceConfigurator { $allowParent = !$this->defaults->getChanges() && empty($this->instanceof); $definition = $this->container->getDefinition($id); return new ServiceConfigurator($this->container, $definition->getInstanceofConditionals(), $allowParent, $this, $definition, $id, []); } public final function __invoke(string $id, string $class = null) : ServiceConfigurator { return $this->set($id, $class); } public function __destruct() { $this->loader->registerAliasesForSinglyImplementedInterfaces(); } } 