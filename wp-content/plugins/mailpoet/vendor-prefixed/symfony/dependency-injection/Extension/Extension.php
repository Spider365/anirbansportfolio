<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection\Extension; if (!defined('ABSPATH')) exit; use MailPoetVendor\Symfony\Component\Config\Definition\ConfigurationInterface; use MailPoetVendor\Symfony\Component\Config\Definition\Processor; use MailPoetVendor\Symfony\Component\DependencyInjection\Container; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\BadMethodCallException; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException; abstract class Extension implements ExtensionInterface, ConfigurationExtensionInterface { private $processedConfigs = []; public function getXsdValidationBasePath() { return \false; } public function getNamespace() { return 'http://example.org/schema/dic/' . $this->getAlias(); } public function getAlias() { $className = static::class; if (!\str_ends_with($className, 'Extension')) { throw new BadMethodCallException('This extension does not follow the naming convention; you must overwrite the getAlias() method.'); } $classBaseName = \substr(\strrchr($className, '\\'), 1, -9); return Container::underscore($classBaseName); } public function getConfiguration(array $config, ContainerBuilder $container) { $class = static::class; if (\str_contains($class, "\0")) { return null; } $class = \substr_replace($class, '\\Configuration', \strrpos($class, '\\')); $class = $container->getReflectionClass($class); if (!$class) { return null; } if (!$class->implementsInterface(ConfigurationInterface::class)) { @\trigger_error(\sprintf('Not implementing "%s" in the extension configuration class "%s" is deprecated since Symfony 4.1.', ConfigurationInterface::class, $class->getName()), \E_USER_DEPRECATED); return null; } if (!($constructor = $class->getConstructor()) || !$constructor->getNumberOfRequiredParameters()) { return $class->newInstance(); } return null; } protected final function processConfiguration(ConfigurationInterface $configuration, array $configs) : array { $processor = new Processor(); return $this->processedConfigs[] = $processor->processConfiguration($configuration, $configs); } public final function getProcessedConfigs() : array { try { return $this->processedConfigs; } finally { $this->processedConfigs = []; } } protected function isConfigEnabled(ContainerBuilder $container, array $config) { if (!\array_key_exists('enabled', $config)) { throw new InvalidArgumentException("The config array has no 'enabled' key."); } return (bool) $container->getParameterBag()->resolveValue($config['enabled']); } } 